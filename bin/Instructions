Projektet

Maximal matchning

Ha alltid en sourcenode (s) och en sink (t).

Alla noder på västersidan har en koppling till source (s)

Alla noder på högersidan har en koppling till sink (t)

Bågar kopplar ihop noder.

Algoritmen gör en Djupet först-sökning först.
1. Finns det en väg mellan s. och t? (bfs-metoden)
2. Gå tillbaka och ta minus flödet.

Flödet är det minsta värdet i en väg.

Finns det matchningar?

Spara den som är det minsta flowet.
Exempel: Flödet är 1. 1-1=0. Kopplingen försvinner!

Djupet-först med en kö är bättre för om man tar Bredden-först blir det som en stack istället.

Alla noder sätts till false från början eftersom de inte är besökta än!

q står för kö

Algoritmen håller på tills kön är tom.

BF:
	public boolean bfs(int[][] graph, int source, int sink) {
		bool pathFound = false;
		
		for i = 0 to numberOfNodes
				visited[i] = false;
				
			q.add(source)
			vistied[source] = true;
			path[source] = -1;
				
				while(q.size() != 0) {
					int element = q.removeFirst();
					
					for i = 0 to numberOfNodes
							if (!visited[i] && graph[element][i] == 1) {
								visited[i] = true;
								path[i] = element;
								q.add(i);
							}
				}
				
				if (visited[sink]) {
					pathFound = true;
					return pathFound;
				}
	}